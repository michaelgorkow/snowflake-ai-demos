-- ============================================================================
-- EXAMPLE BUSINESS QUERIES
-- ============================================================================
USE SCHEMA AI_DEMOS.SVA_DEMO;

-- Query 1: Which CATEGORY saw the highest growth in NET_SALES during IS_HOLIDAY periods compared to the rest of the year?
-- This query compares holiday vs non-holiday sales by product category to identify seasonal performance
WITH holiday_sales AS (
    SELECT 
        p.CATEGORY,
        SUM(CASE WHEN d.IS_HOLIDAY THEN f.NET_SALES ELSE 0 END) AS HOLIDAY_NET_SALES,
        SUM(CASE WHEN NOT d.IS_HOLIDAY THEN f.NET_SALES ELSE 0 END) AS NON_HOLIDAY_NET_SALES,
        COUNT(DISTINCT CASE WHEN d.IS_HOLIDAY THEN d.DATE_KEY END) AS HOLIDAY_DAYS,
        COUNT(DISTINCT CASE WHEN NOT d.IS_HOLIDAY THEN d.DATE_KEY END) AS NON_HOLIDAY_DAYS
    FROM SVA_DEMO.PUBLIC.FACT_SALES f
    JOIN SVA_DEMO.PUBLIC.DIM_DATE d ON f.DATE_KEY = d.DATE_KEY
    JOIN SVA_DEMO.PUBLIC.DIM_PRODUCT p ON f.PRODUCT_KEY = p.PRODUCT_KEY
    GROUP BY p.CATEGORY
)
SELECT 
    CATEGORY,
    ROUND(HOLIDAY_NET_SALES, 2) AS HOLIDAY_NET_SALES,
    ROUND(NON_HOLIDAY_NET_SALES, 2) AS NON_HOLIDAY_NET_SALES,
    ROUND(HOLIDAY_NET_SALES / NULLIF(HOLIDAY_DAYS, 0), 2) AS AVG_DAILY_HOLIDAY_SALES,
    ROUND(NON_HOLIDAY_NET_SALES / NULLIF(NON_HOLIDAY_DAYS, 0), 2) AS AVG_DAILY_NON_HOLIDAY_SALES,
    ROUND(((HOLIDAY_NET_SALES / NULLIF(HOLIDAY_DAYS, 0)) - (NON_HOLIDAY_NET_SALES / NULLIF(NON_HOLIDAY_DAYS, 0))) 
          / NULLIF((NON_HOLIDAY_NET_SALES / NULLIF(NON_HOLIDAY_DAYS, 0)), 0) * 100, 2) AS HOLIDAY_GROWTH_PCT
FROM holiday_sales
ORDER BY HOLIDAY_GROWTH_PCT DESC;

-- Query 2: Is there a correlation between an EMPLOYEE_KEY and the average DISCOUNT_AMOUNT granted?
-- This query analyzes discount patterns by employee to identify potential training or policy compliance issues
SELECT 
    e.EMPLOYEE_KEY,
    e.EMPLOYEE_NAME,
    e.JOB_TITLE,
    COUNT(f.SALES_ID) AS TOTAL_TRANSACTIONS,
    ROUND(AVG(f.DISCOUNT_AMOUNT), 2) AS AVG_DISCOUNT_AMOUNT,
    ROUND(SUM(f.DISCOUNT_AMOUNT), 2) AS TOTAL_DISCOUNT_GIVEN,
    ROUND(AVG(f.DISCOUNT_AMOUNT / NULLIF(f.QUANTITY * f.UNIT_PRICE, 0)) * 100, 2) AS AVG_DISCOUNT_PCT,
    ROUND(SUM(f.NET_SALES), 2) AS TOTAL_NET_SALES
FROM SVA_DEMO.PUBLIC.FACT_SALES f
JOIN SVA_DEMO.PUBLIC.DIM_EMPLOYEE e ON f.EMPLOYEE_KEY = e.EMPLOYEE_KEY
GROUP BY e.EMPLOYEE_KEY, e.EMPLOYEE_NAME, e.JOB_TITLE
ORDER BY AVG_DISCOUNT_AMOUNT DESC;

-- Query 3: Which REGION has the lowest NET_SALES per LOYALTY_SEGMENT?
-- This query identifies underperforming regions by customer loyalty tier for targeted marketing
SELECT 
    s.REGION,
    c.LOYALTY_SEGMENT,
    COUNT(DISTINCT c.CUSTOMER_KEY) AS CUSTOMER_COUNT,
    ROUND(SUM(f.NET_SALES), 2) AS TOTAL_NET_SALES,
    ROUND(SUM(f.NET_SALES) / NULLIF(COUNT(DISTINCT c.CUSTOMER_KEY), 0), 2) AS NET_SALES_PER_CUSTOMER
FROM SVA_DEMO.PUBLIC.FACT_SALES f
JOIN SVA_DEMO.PUBLIC.DIM_STORE s ON f.STORE_KEY = s.STORE_KEY
JOIN SVA_DEMO.PUBLIC.DIM_CUSTOMER c ON f.CUSTOMER_KEY = c.CUSTOMER_KEY
GROUP BY s.REGION, c.LOYALTY_SEGMENT
ORDER BY c.LOYALTY_SEGMENT, NET_SALES_PER_CUSTOMER ASC;

-- Query 4: When a new SUB_CATEGORY is introduced, how does it impact QUANTITY sold of existing products within the same BRAND?
-- This query compares sales before/after new sub-category introductions (Wearables & Gaming added June 2024)
WITH new_subcategory_intro AS (
    SELECT '2024-06-01'::DATE AS INTRO_DATE, 'TechVision' AS BRAND, 'Wearables' AS NEW_SUBCAT
    UNION ALL
    SELECT '2024-06-01'::DATE, 'ByteForce', 'Gaming'
),
brand_sales_comparison AS (
    SELECT 
        p.BRAND,
        n.NEW_SUBCAT AS NEW_SUBCATEGORY_INTRODUCED,
        SUM(CASE WHEN d.FULL_DATE < n.INTRO_DATE AND p.SUB_CATEGORY != n.NEW_SUBCAT THEN f.QUANTITY ELSE 0 END) AS QTY_BEFORE_EXISTING,
        SUM(CASE WHEN d.FULL_DATE >= n.INTRO_DATE AND p.SUB_CATEGORY != n.NEW_SUBCAT THEN f.QUANTITY ELSE 0 END) AS QTY_AFTER_EXISTING,
        SUM(CASE WHEN d.FULL_DATE >= n.INTRO_DATE AND p.SUB_CATEGORY = n.NEW_SUBCAT THEN f.QUANTITY ELSE 0 END) AS QTY_NEW_SUBCAT,
        DATEDIFF('day', MIN(d.FULL_DATE), n.INTRO_DATE) AS DAYS_BEFORE,
        DATEDIFF('day', n.INTRO_DATE, MAX(d.FULL_DATE)) AS DAYS_AFTER
    FROM SVA_DEMO.PUBLIC.FACT_SALES f
    JOIN SVA_DEMO.PUBLIC.DIM_DATE d ON f.DATE_KEY = d.DATE_KEY
    JOIN SVA_DEMO.PUBLIC.DIM_PRODUCT p ON f.PRODUCT_KEY = p.PRODUCT_KEY
    JOIN new_subcategory_intro n ON p.BRAND = n.BRAND
    GROUP BY p.BRAND, n.NEW_SUBCAT, n.INTRO_DATE
)
SELECT 
    BRAND,
    NEW_SUBCATEGORY_INTRODUCED,
    QTY_BEFORE_EXISTING,
    QTY_AFTER_EXISTING,
    QTY_NEW_SUBCAT,
    ROUND(QTY_BEFORE_EXISTING / NULLIF(DAYS_BEFORE, 0), 2) AS DAILY_AVG_BEFORE,
    ROUND(QTY_AFTER_EXISTING / NULLIF(DAYS_AFTER, 0), 2) AS DAILY_AVG_AFTER,
    ROUND(((QTY_AFTER_EXISTING / NULLIF(DAYS_AFTER, 0)) - (QTY_BEFORE_EXISTING / NULLIF(DAYS_BEFORE, 0))) 
          / NULLIF((QTY_BEFORE_EXISTING / NULLIF(DAYS_BEFORE, 0)), 0) * 100, 2) AS EXISTING_PRODUCT_IMPACT_PCT
FROM brand_sales_comparison;

-- Query 5: What is the average time elapsed between the first and second purchase for 'Premium' customers?
-- This query measures customer engagement velocity for the Premium loyalty segment
WITH customer_purchases AS (
    SELECT 
        f.CUSTOMER_KEY,
        c.LOYALTY_SEGMENT,
        d.FULL_DATE,
        ROW_NUMBER() OVER (PARTITION BY f.CUSTOMER_KEY ORDER BY d.FULL_DATE) AS PURCHASE_RANK
    FROM SVA_DEMO.PUBLIC.FACT_SALES f
    JOIN SVA_DEMO.PUBLIC.DIM_CUSTOMER c ON f.CUSTOMER_KEY = c.CUSTOMER_KEY
    JOIN SVA_DEMO.PUBLIC.DIM_DATE d ON f.DATE_KEY = d.DATE_KEY
    WHERE c.LOYALTY_SEGMENT = 'Premium'
),
first_second_purchase AS (
    SELECT 
        CUSTOMER_KEY,
        MAX(CASE WHEN PURCHASE_RANK = 1 THEN FULL_DATE END) AS FIRST_PURCHASE_DATE,
        MAX(CASE WHEN PURCHASE_RANK = 2 THEN FULL_DATE END) AS SECOND_PURCHASE_DATE
    FROM customer_purchases
    WHERE PURCHASE_RANK <= 2
    GROUP BY CUSTOMER_KEY
    HAVING MAX(CASE WHEN PURCHASE_RANK = 2 THEN FULL_DATE END) IS NOT NULL
)
SELECT 
    COUNT(*) AS PREMIUM_CUSTOMERS_WITH_REPEAT_PURCHASE,
    ROUND(AVG(DATEDIFF('day', FIRST_PURCHASE_DATE, SECOND_PURCHASE_DATE)), 1) AS AVG_DAYS_BETWEEN_PURCHASES,
    MIN(DATEDIFF('day', FIRST_PURCHASE_DATE, SECOND_PURCHASE_DATE)) AS MIN_DAYS,
    MAX(DATEDIFF('day', FIRST_PURCHASE_DATE, SECOND_PURCHASE_DATE)) AS MAX_DAYS,
    ROUND(MEDIAN(DATEDIFF('day', FIRST_PURCHASE_DATE, SECOND_PURCHASE_DATE)), 1) AS MEDIAN_DAYS
FROM first_second_purchase;